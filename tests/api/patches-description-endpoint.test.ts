import { describe, it, expect, beforeEach, afterEach, jest } from '@jest/globals';
import { NextRequest } from 'next/server';
import { Patch } from '@/lib/models/Patch';
import { Gear } from '@/lib/models/Gear';
import { saveToKV, getFromKV } from '@/lib/kv';

// Mock the fetch function for OpenAI API calls
global.fetch = jest.fn().mockImplementation((url) => {
  if (url === 'https://api.openai.com/v1/chat/completions') {
    return Promise.resolve({
      ok: true,
      json: () => Promise.resolve({
        choices: [
          {
            message: {
              content: 'Test patch description generated by the model',
            },
          },
        ],
      }),
    });
  }
  
  // For other API calls
  return Promise.resolve({
    ok: true,
    json: () => Promise.resolve({}),
  });
});

// Import the handler after mocking
import { POST } from '@/app/api/patches/[patchId]/description/route';

describe('Patch Description Endpoint', () => {
  let testGear1: Gear;
  let testGear2: Gear;
  let testPatch: Patch;
  
  beforeEach(async () => {
    // Clear mocks
    jest.clearAllMocks();
    
    // Set up in-memory test data
    testGear1 = await Gear.create({
      id: 'test-gear-1',
      label: 'Data Analyzer',
      messages: [
        { role: 'system', content: 'You analyze data and provide insights.' },
      ],
      outputUrls: []
    });
    
    testGear2 = await Gear.create({
      id: 'test-gear-2',
      label: 'Report Generator',
      messages: [
        { role: 'system', content: 'You generate formatted reports.' },
      ],
      outputUrls: []
    });
    
    // Create a patch with nodes
    testPatch = await Patch.create({
      id: 'test-description-endpoint-patch',
      name: 'Data Pipeline',
      description: '',
      nodes: [
        {
          id: 'node-1',
          type: 'gearNode',
          position: { x: 100, y: 100 },
          data: {
            gearId: 'test-gear-1',
            label: 'Data Analyzer'
          }
        },
        {
          id: 'node-2',
          type: 'gearNode',
          position: { x: 300, y: 100 },
          data: {
            gearId: 'test-gear-2',
            label: 'Report Generator'
          }
        }
      ],
      edges: [
        {
          id: 'edge-1-2',
          source: 'node-1',
          target: 'node-2'
        }
      ]
    });
    
    // Verify the test gear and patch were saved
    expect(await getFromKV(`gear:test-gear-1`)).not.toBeNull();
    expect(await getFromKV(`gear:test-gear-2`)).not.toBeNull();
    expect(await getFromKV(`patch:test-description-endpoint-patch`)).not.toBeNull();
  });
  
  afterEach(async () => {
    // Clean up test data
    await saveToKV(`gear:test-gear-1`, null);
    await saveToKV(`gear:test-gear-2`, null);
    await saveToKV(`patch:test-description-endpoint-patch`, null);
  });
  
  it('should generate a description for a patch', async () => {
    // Create a mock request
    const request = new NextRequest('http://localhost:3000/api/patches/test-description-endpoint-patch/description', {
      method: 'POST',
    });
    
    // Mock params
    const params = Promise.resolve({ patchId: 'test-description-endpoint-patch' });
    
    // Call the endpoint
    const response = await POST(request, { params });
    
    // We expect a success response with the description
    expect(response.status).toBe(200);
    
    // Check content
    const description = await response.text();
    expect(description).toBe('Test patch description generated by the model');
  });
  
  it('should return 404 for non-existent patch', async () => {
    // Create a mock request
    const request = new NextRequest('http://localhost:3000/api/patches/non-existent-patch/description', {
      method: 'POST',
    });
    
    // Mock params
    const params = Promise.resolve({ patchId: 'non-existent-patch' });
    
    // Call the endpoint
    const response = await POST(request, { params });
    
    // We expect a 404 response
    expect(response.status).toBe(404);
  });
});